package reflection;


import static common.utils.PrintUtil.println;

public class _01_ClassNameDifference {

    /**
     * the name is the name that you'd use to dynamically load the class with, for example, a call to Class.forName with the default ClassLoader.
     *     Within the scope of a certain ClassLoader, all classes have unique names.
     * the canonical name is the name that would be used in an import statement.
     *     It might be useful during toString or logging operations.
     *     When the javac compiler has complete view of a classpath, it enforces uniqueness of canonical names within it by clashing fully qualified class and package names at compile time.
     *     However JVMs must accept such name clashes, and thus canonical names do not uniquely identifies classes within a ClassLoader.
     *     (In hindsight, a better name for this getter would have been getJavaName; but this method dates from a time when the JVM was used solely to run Java programs.)
     * the simple name loosely identifies the class, again might be useful during toString or logging operations but is not guaranteed to be unique.
     * the type name returns "an informative string for the name of this type", "It's like toString(): it's purely informative and has no contract value" (as written by sir4ur0n)
     *
     * Here are the rules
     * If the class object represents a primitive type or void, all the four methods simply returns its name.
     * Now the rules for the getName() method:
     *     Every non-lambda and non-array class or interface (i.e, top-level, nested, inner, local and anonymous) has a name (which is returned by getName()) that is the package name followed by a dot (if there is a package), followed by the name of its class-file as generated by the compiler (whithout the suffix .class).
     *         If there is no package, it is simply the name of the class-file. If the class is an inner, nested, local or anonymous class, the compiler should generate at least one $ in its class-file name.
     *         Note that for anonymous classes, the class name would end with a dollar-sign followed by a number.
     *     Lambda class names are generally unpredictable, and you shouldn't care about they anyway.
     *         Exactly, their name is the name of the enclosing class, followed by $$Lambda$, followed by a number, followed by a slash, followed by another number.
     *     The class descriptor of the primitives are Z for boolean, B for byte, S for short, C for char, I for int, J for long, F for float and D for double.
     *         For non-array classes and interfaces the class descriptor is L followed by what is given by getName() followed by ;.
     *         For array classes, the class descriptor is [ followed by the class descriptor of the component type (which may be itself another array class).
     *     For array classes, the getName() method returns its class descriptor.
     *         This rule seems to fail only for array classes whose the component type is a lambda (which possibly is a bug), but hopefully this should not matter anyway because there is no point even on the existence of array classes whose component type is a lambda.
     * Now, the toString() method:
     *     If the class instance represents an interface (or an annotation, which is a special type of interface), the toString() returns "interface " + getName().
     *         If it is a primitive, it returns simply getName(). If it is something else (a class type, even if it is a pretty weird one), it returns "class " + getName().
     * The getCanonicalName() method:
     *     For top-level classes and interfaces, the getCanonicalName() method returns just what the getName() method returns.
     *     The getCanonicalName() method returns null for anonymous or local classes and for array classes of those.
     *     For inner and nested classes and interfaces, the getCanonicalName() method returns what the getName() method would replacing the compiler-introduced dollar-signs by dots.
     *     For array classes, the getCanonicalName() method returns null if the canonical name of the component type is null. Otherwise, it returns the canonical name of the component type followed by [].
     * The getSimpleName() method:
     *     For top-level, nested, inner and local classes, the getSimpleName() returns the name of the class as written in the source file.
     *     For anonymous classes the getSimpleName() returns an empty String.
     *     For lambda classes the getSimpleName() just returns what the getName() would return without the package name.
     *         This do not makes much sense and looks like a bug for me, but there is no point in calling getSimpleName() on a lambda class to start with.
     *     For array classes the getSimpleName() method returns the simple name of the component class followed by [].
     *         This have the funny/weird side-effect that array classes whose component type is an anonymous class have just [] as their simple names.
     *
     */
    static void printlnInfo(Class clazz) {
        println("Simple name: " + clazz.getSimpleName() + " is interface? [" + clazz.isInterface() + "]");
        println("Class name: " + clazz.getName());
        println("Type name : " + clazz.getTypeName());
        println("Canonical name : " + clazz.getCanonicalName());

        println("------------------------------------------------------------");
    }

    interface Interface1 {
    }

    interface Interface2 {
    }

    interface Interface3 {
    }

    static class SuperClass {
        // Comment out the following default constructor to see NoSuchMethodError from (*1*)
        SuperClass() {
        }

        SuperClass(int i) {
        }
    }

    static class SubClass extends SuperClass implements Interface1, Interface2, Interface3 {
        SubClass() {
            super(1);
        }
    }

    public static void main(String[] args) {
        Class c = null;

        try {
            c = Class.forName("reflection._01_ClassNameDifference$SubClass");
            printlnInfo(c);
        } catch (ClassNotFoundException e) {
            println("Can't find SubClass");
        }

        for (Class face : c.getInterfaces()) {
            printlnInfo(face);
        }

        Class up = c.getSuperclass();
        Object obj = null;
        try {
            obj = up.newInstance(); // Requires default constructor:
            printlnInfo(obj.getClass());
        } catch (InstantiationException e) {
            println("Cannot instantiate");
        } catch (IllegalAccessException e) {
            println("Cannot access");
        }
    }
}